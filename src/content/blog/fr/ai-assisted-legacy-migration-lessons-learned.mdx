---
date: '2025-11-14'
language: 'fr'
title: "Migration Legacy Assistée par IA : Retour d'expérience"
category: 'Development'
image: '/images/articles/ai-migration-journey.png'
description: "Une rétrospective de l'utilisation intensive des outils IA pour une migration d'une large codebase, des échecs initiaux à un workflow qui fonctionne réellement."
timeToRead: 12
alternates:
  en: 'ai-assisted-legacy-migration-lessons-learned'
  fr: 'ai-assisted-legacy-migration-lessons-learned'
---

"Ça va être incroyable", ai-je pensé en regardant Claude Code analyser des milliers de lignes de code legacy. "Je vais juste lui donner le endpoint legacy à analyser, et l'IA va tout migrer. Cette migration qui prendrait des mois ? Terminée en quelques semaines."

Quatre heures plus tard, je fixais un écran rempli d'hallucinations qui référençait avec assurance des fonctions qui n'existaient pas, implémentait des patterns que nous n'avions jamais utilisés, et qui aurait cassé la production de manière spectaculaire. C'était le Jour 1, et mes illusions venaient de se fracasser contre la réalité.

Bienvenue dans mon voyage de sept semaines pour découvrir comment utiliser l'IA pour une migration d'une large codebase legacy. Pas la version formateur YouTube promettant des miracles, mais la réalité désordonnée, frustrante et finalement productive de cette transformation.

## Le Défi : Bienvenue dans le Monde Réel

Oubliez les articles de blog sur l'utilisation de ChatGPT pour construire une application todo. Il s'agissait d'une migration de code de production : extraire des fonctionnalités d'un monolithe legacy et les reconstruire dans un monorepo TypeScript. Pas un projet greenfield où les erreurs ne coûtent pas cher. Pas un prototype où "assez bon" suffit.

Migration réelle. Enjeux réels. Complexité réelle :

- **Systèmes interconnectés** où changer une chose en casse trois autres dont vous ne saviez pas l'existence
- **Connaissance du domaine** enterrée dans des commentaires de 2011, dispersée dans plusieurs repositories Git, vivant seulement dans la tête des développeurs seniors
- **Décisions architecturales** qui nécessitent de comprendre pourquoi quelque chose a été construit d'une certaine manière avant de pouvoir le reconstruire différemment
- **Standards de qualité** où "ça marche sur ma machine" n'est pas acceptable

C'est là que les outils IA promettent le plus de valeur - et où la plupart d'entre eux échouent spectaculairement.

## Semaine 1 : Quand l'Espoir Rencontre la Réalité

### 18 Septembre : Le Prompt Divin

Ma stratégie était simple : créer un prompt parfait contenant tout. La spécification complète de la fonctionnalité. Le contexte du code legacy. Les patterns de la nouvelle architecture. Les exigences de migration. Tout.

J'ai appuyé sur Entrée et regardé Claude Code réfléchir. Et réfléchir. Et réfléchir encore.

Dix minutes plus tard, il a livré un plan de migration complet avec des étapes d'implémentation détaillées, un formatage magnifique et des explications confiantes. Le problème ? C'était une hallucination complète.

L'IA avait inventé une couche de cache que nous n'avions pas, référencé un pattern de gestion d'état que nous n'avions jamais utilisé, et proposé de migrer les appels base de données vers un ORM que nous n'utilisions pas. C'était impressionnant de faux, et j'ai perdu trop d'heures à essayer de comprendre pourquoi rien ne correspondait à notre codebase réelle. L'IA n'analysait pas notre code - elle faisait du pattern-matching avec ses données d'entraînement et espérait pour le mieux.

### 19 Septembre : Briser le Fantasme

Bien. Plan B : au lieu d'un méga-prompt, le découper. Prompt d'analyse. Prompt de planification. Prompt de revue. Prompt de spécification de tests.

Les résultats se sont immédiatement améliorés. Les hallucinations sont passées de "fiction complète" à "plutôt précis avec interprétation créative". Progrès !

Mais voilà le problème : "plutôt précis" n'est pas une chose acceptable dans le code de production. Vous ne pouvez pas déployer une fonctionnalité correcte à 85%. Ces 15% restants ? C'est là que vivent les bugs.

Je passais plus de temps à vérifier les sorties de l'IA que j'en aurais passé à lire le code moi-même.

## Semaine 2 : La Vérité Inconfortable

### 22 Septembre : Quand Je Suis Devenu le Goulot d'Étranglement

Après trois jours de lutte contre les hallucinations, le pattern est devenu clair : **à chaque fois que je comprenais réellement le code legacy avant de prompter l'IA, la sortie était dramatiquement meilleure**.

C'était presque embarrassant à quel point cela aurait dû être évident.

Quand je demandais aveuglément à l'IA d'analyser du code :

```
"Analyse ce module d'authentification et crée un plan de migration"
→ L'IA invente des patterns, fait des suppositions, confiant mais faux
```

Quand je l'analysais d'abord, puis demandais à l'IA :

```
"Ce module d'auth utilise des tokens JWT avec une stratégie de refresh personnalisée stockée dans Redis.
L'implémentation legacy a trois cas limites : [cas spécifiques].
Crée un plan de migration qui gère ces cas en utilisant notre nouveau service d'auth."
→ L'IA génère un plan précis et utilisable
```

La différence n'était pas l'IA. La différence c'était moi faisant mon travail d'abord.

**Quatre règles durement acquises ont émergé :**

1. **L'ambiguïté tue la précision** - Chaque prompt vague produisait des hallucinations, tandis que chaque prompt spécifique produisait du code utilisable.
2. **On ne peut pas sauter la phase de compréhension** - L'IA amplifie votre compréhension du code ; elle ne peut pas la remplacer.
3. **L'IA génère du bruit qu'il faut filtrer** - Les specs nécessitaient un filtrage manuel car l'IA inclurait chaque détail tangentiellement lié, noyant l'essentiel dans l'accessoire.
4. **La validation reste non négociable** - Une revue humaine minutieuse de chaque spec, chaque plan, chaque supposition était indispensable.

Le nouveau workflow : **Analyse IA → Analyse humaine → Prompt détaillé → Génération IA → Validation humaine**

Pensez pair programming, où vous êtes le dev senior et l'IA est le junior talentueux qui a besoin de directions claires.

### L'Erreur Auto-Accept

J'ai aussi tiré une leçon importante : il fallait désactiver l'auto-accept pour les modifications IA. Regarder l'IA modifier automatiquement des fichiers pendant que je prenais un café pouvait sembler productif, mais en réalité c'était simplement jouer avec le code de production de manière risquée.

## Semaine 3 : La Facture Arrive

### 29 Septembre : Parlons du Temps

Il est temps d'affronter la musique. J'ai commencé à suivre les heures réelles :

**Par migration de fonctionnalité :**

- 25 minutes : Planification (lecture du legacy par IA, écriture des specs par IA, relecture humaine)
- 2h30 : Implémentation avec IA (révision de chaque changement)
- Inconnu : Débogage de la dérive architecturale

Ces 2h30 de "pair programming" avec l'IA ? La moitié c'était :

- Corriger le cap quand l'IA devenait folle
- Expliquer pourquoi on ne peut pas "juste tout refactoriser pour utiliser les derniers patterns"
- Annuler des changements parce que la fenêtre de contexte de l'IA s'était remplie et qu'elle avait oublié ce qu'on faisait

La vérité brutale : **l'IA prenait des décisions architecturales qu'elle n'avait aucune raison de prendre.**

**L'over-engineering est l'ennemie de la productivité**

## Octobre : Le Mois Où Tout A Cassé (Puis s'est amélioré)

### 3 Octobre : L'Épiphanie Multi-Modèle

Les spécifications initiales que j'avais créées ? Utiles pour cadrer, mais trop superficielles. L'IA continuait à faire de mauvaises suppositions parce que mes specs étaient trop approximatives.

Puis j'ai eu une idée : et si je faisais analyser le code legacy par plusieurs modèles IA indépendamment, puis fusionnais leurs insights ?

**L'expérience :**

- Claude analyse le flux d'authentification
- Codex analyse le flux d'authentification
- Cursor analyse le flux d'authentification
- Claude fusionne les trois perspectives en vérifiant le legacy et en validant les découvertes

Claude a remarqué les patterns de gestion d'erreur, Codex a attrapé les cas limites, et Cursor a identifié les considérations de performance. Aucun d'eux n'a tout capturé seul, mais ensemble ils offraient une couverture complète. C'était comme avoir trois devs juniors faire une revue de code - chacun attrape des problèmes différents.

L'approche multi-modèle demandait certes plus de temps au départ, mais l'amélioration de la qualité était dramatique. Les erreurs de chaque modèle étaient systématiquement attrapées par les autres, créant un système de validation croisée particulièrement efficace.

### 13 Octobre : Le Fond du Gouffre

J'ai décidé de tester le "développement IA autonome". Lui donner une spec claire, le laisser tourner, voir ce qui se passe.

Les résultats étaient... éducatifs.

**Ce que l'IA a livré :**

- Des types branded qui avaient l'air corrects mais avaient les mauvais types
- Des variables avec des noms suggérant un but mais des types impliquant autre chose
- Une couche d'abstraction tellement over-engineered qu'elle nécessitait des abstractions pour les abstractions

**Le pire ?** Le code compilait, les tests passaient, et ça avait l'air professionnel. Mais c'était faux de manière subtile et insidieuse - le genre de faux qui glisse en production et cause des bugs un mois plus tard quand quelqu'un essaie de l'étendre.

J'ai passé plus de temps à corriger du code IA "fonctionnel" que j'en aurais passé à l'écrire correctement from scratch. C'était mon moment le plus bas, celui où je me suis demandé si tout cela faisait vraiment gagner du temps ou si je créais simplement de la dette technique à la vitesse de l'IA.

### 17 Octobre : L'Apocalypse Code Review

**Je générais du code plus vite que l'équipe ne pouvait le reviewer.**

Standup du lundi matin :

- "J'ai 3 PRs prêtes pour revue"
- "Chaque PR change 50-70 fichiers"
- "Elles sont toutes bloquées en attente de revue"

L'équipe ne pouvait pas suivre. Les PRs s'empilaient comme la neige dans une tempête.

**PRs petites fréquentes ?** Devenaient bloquantes. Tout le monde passait la journée à faire des revues de code au lieu d'écrire du code.

**PRs larges moins fréquentes ?** Illisibles. "Tu peux reviewer ces 80 changements de fichiers ?" Détestation de l'équipe assurée.

L'ironie : l'IA m'avait rendu si rapide que j'étais devenu le goulot d'étranglement de l'équipe.

On avait besoin d'une nouvelle stratégie. Branches de fonctionnalités imbriquées ? Flux de développement parallèles ? Meilleure séparation des préoccupations pour que les PRs puissent être reviewées indépendamment ?

Tout ce qui précède, probablement.

## Fin Octobre : La Révélation de l'Orchestration

### 22 Octobre : Le Salut en Cinq Étapes

Après plusieurs semaines de chaos, le pattern s'est finalement cristallisé. Chaque migration réussie suivait les mêmes cinq étapes :

1. **Définir un scope précis** (pas "migrer l'auth" mais "migrer la gestion du refresh token JWT avec fallback Redis")
2. **Le comprendre complètement** (vraiment lire le code legacy, pas juste le survoler)
3. **L'IA planifie en mode PLAN** (obtenir la stratégie avant tout code)
4. **Tout valider** (l'IA fait de bonnes suggestions et de terribles suppositions)
5. **Générer avec supervision** (auto-accept toujours désactivé, revue de chaque changement)

Simple. Évident avec le recul. Mais il a fallu un mois d'erreurs pour l'apprendre.

### 23 Octobre : La Percée Slash Command

Session de codage tard dans la nuit. Attendez, c'est quoi ça ?

**Claude Code peut déclencher des commandes slash lui même dans des sub-agents.**

Mon cerveau est immédiatement allé vers : "Et si j'orchestrais plusieurs agents IA ?"

À 2h du matin, j'avais un prototype fonctionnel :

- `/scout-explorer` → plusieurs agents analysent le codebase en parallèle via Claude, Codex et Cursor
- `/specification-plan` → synthétisent les découvertes en une spec cohérente
- `/build-prd` → génèrent un plan d'implémentation détaillé

**Premier test :** L'analyse prenait trois fois plus de temps qu'avec un prompt manuel, mais la qualité était nettement meilleure et la complétude du PRD était enfin réellement satisfaisante. Je tenais quelque chose.

### 24 Octobre : Quand la Magie Cesse de Fonctionner

**Le problème :** L'orchestrateur était fragile. Ça marchait bien quand tout se passait comme prévu, mais dès que quelque chose tournait mal - non respect des consignes de l'IA, limite de tokens, ou prompt ambigu - tout s'effondrait.

Les prompts complexes vers Codex via les outils CLI étaient peu fiables. La coordination multi-agents multi-étapes ne fonctionnait qu'une fois sur trois. Dépendre de Claude Code pour gérer l'orchestration s'est révélé impossible.

Le rêve de l'automation "set it and forget it" est mort ce jour-là. J'avais besoin de quelque chose de plus stable, quelque chose que je contrôlais vraiment, et qui ne déciderait pas aléatoirement d'interpréter mes instructions de manière créative.

---

## Novembre : Quand Ça Click Enfin

### 2 Novembre : Construire Mon Propre Outil

J'en avais assez de dépendre des caprices de l'IA pour l'orchestration. Il était temps de construire quelque chose de véritablement fiable. Le temps d'une soirée, j'ai construit une CLI qui orchestre tout le workflow d'analyse. Rien d'intelligent ou de fancy, juste quelque chose de fiable et prévisible.

**Le flux :**

```
$ migration-cli analyze

→ "Quels repositories ?"  [prompt interactif]
→ "Quels modèles IA ?"    [Claude Sonnet, Claude Haiku, Codex GPT5, Cursor Composer1 - choix multiple]
→ "Description de la tâche ?" [spécifique, pas vague]
→ "Points d'entrée ?"     [où commencer l'analyse]
→ "Scope ?"              [ce qui est inclus, ce qui ne l'est pas]

[La CLI tourne en arrière-plan]
→ Clone les repos legacy concernés
→ Lance les modèles choisis en parallèle
→ Chacun analyse indépendamment
→ Fusionne les résultats en une analyse cohérente
→ Génère le PRD
→ Découpe en tâches atomiques
→ Revue parallèle de chaque tâche
→ Génère le cahier de test

Terminé.
```

Le premier run a pris 15 minutes d'analyse et a produit un PRD complet sans aucune hallucination. Le deuxième run a maintenu la même qualité. Au dixième run, la cohérence était toujours au rendez-vous. J'avais enfin atteint la répétabilité tant recherchée.

### 3 Novembre : La Révélation de la Fenêtre de Contexte

J'ai découvert que la qualité de l'IA s'effondre après environ 60% d'utilisation de la fenêtre de contexte. Ce n'est pas une dégradation progressive mais une véritable falaise : à 50% tout fonctionne bien, à 60% les hallucinations commencent à apparaître.

**La solution :**

- Stocké le contexte pertinent de la tâche en cours dans un fichier `.work-in-progress.md`
- Supprimé les serveurs MCP trop gourmands en contexte (je te regarde, Atlassian mangeant 18% de contexte juste en existant)

Avec cette approche, les migrations pouvaient tourner aussi longtemps que nécessaire sans aucune dégradation de qualité.

### 4 Novembre : Après l'Analyse, Le Code

La pièce manquante : des prompts standardisés.

J'ai créé trois fichiers d'instructions :

- `01_plan.md` - Comment analyser et planifier
- `02_code.md` - Comment implémenter (avec règles de style de code spécifiques)
- `03_review.md` - Comment reviewer pour les erreurs communes

Chaque tâche commence maintenant de la même manière :

1. Lire la tâche et le PRD et suivre les instructions de `01_plan.md`
2. Revue humaine du plan
3. Démarrer l'implémentation en pair programming avec l'IA via les instructions de `02_code.md`

Ajouté `.work-in-progress.md` pour suivre l'état de la tâche courante. Quand le contexte devient lourd ? Tout effacer sauf le fichier WIP. Contexte frais, pas de progrès perdu.

**La règle qui a tout changé :** Effacer le contexte IA religieusement.

Ne laissez pas les conversations grandir. Ne laissez pas les fenêtres de contexte se remplir. Recommencer fréquemment avec seulement l'information essentielle.

Ça semblait gaspilleur au début. "Mais je viens juste d'expliquer l'architecture !"

Puis j'ai réalisé : expliquer l'architecture à un contexte frais prend 2 minutes. Déboguer les hallucinations d'un contexte gonflé prend 2 heures.

Choix facile.

---

## Le Workflow Final : Ce Qui Marche Vraiment

6 novembre. Sept semaines dedans. Le workflow s'est finalement cristallisé en quelque chose de répétable et fiable.

### Phase 1 : Analyse & PRD (La Fondation)

**Lancer le CLI** pour une analyse complète :

- Plusieurs modèles IA travaillent en parallèle
- Validation croisée des découvertes
- Génération d'un PRD détaillé
- Découpage en tâches atomiques

**Puis s'arrêter et valider.**

Ne pas faire confiance aveuglément. Passer du temps à review :

- Est-ce que ce PRD correspond à la réalité ?
- Est-ce que ces tâches sont vraiment atomiques ?
- Quels cas limites l'IA a manqués ?
- Où sont les dépendances cachées ?

Corriger ce qui est faux. Approuver ce qui est juste. Copier vers la nouvelle codebase.

Cette phase de validation, qui prend environ 45 minutes, permet d'éviter des semaines de mauvaises suppositions et de fausses pistes qui auraient pu compromettre tout le projet.

### Phase 2 : Implémentation (La Partie Qu'On Ne Peut Pas Précipiter)

**Pour chaque tâche, suivre ces étapes religieusement :**

**1. Lire le code legacy vous-même**

Pas optionnel. Pas "l'IA va gérer ça". Vous le lisez. Vous le comprenez. Puis vous guidez l'IA.

IA sans votre compréhension = hallucinations.
IA avec votre compréhension = productivité.

**2. Générer le plan** avec `01_plan.md`

Laisser l'IA proposer l'approche. Référencer le PRD. Référencer la tâche. La laisser réfléchir à l'implémentation.

Puis review chaque supposition et orienter l'IA dès le moindre écart.

**3. Si vous démarrez une nouvelle fonctionnalité : Coder l'architecture vous-même**

C'est critique. Ne laissez pas l'IA concevoir votre architecture.

L'IA créera quelque chose qui marche en isolation mais ne s'intègre pas à votre système. Elle ajoutera des abstractions dont vous n'avez pas besoin. Elle fera des choix qui semblent bien maintenant mais font mal plus tard. Cette approche s'est avérée extrêmement rentable : 30 minutes de travail d'architecture manuelle économisaient systématiquement 3 heures de refactoring ultérieur.

**4. Laisser l'IA implémenter les détails** avec `02_code.md`

Maintenant l'IA brille. L'architecture existe. Les patterns sont clairs. Laissez-la générer l'implémentation.

Mais gardez l'auto-accept OFF.

Reviewer chaque fichier. Questionner tout ce qui a l'air "intelligent". L'IA adore être intelligente. Mais vous avez besoin de code qui est ennuyeux et maintenable.

Cette partie est fastidieuse. Vous allez reviewer des douzaines de fichiers. Vous allez rejeter des changements qui marchent mais ne s'intègrent pas.

Faites-le quand même. C'est là que la déviation architecturale est attrapée.

**5. L'IA review son propre travail** avec `03_review.md`

L'IA attrape des erreurs différentes des humains. Utilisez-la.

**6. Rétrospective**

L'IA a fait la même erreur trois fois ? Mettez à jour vos prompts. Enseignez-lui vos patterns ORM. Documentez les conventions de votre équipe. Rendez les prompts plus intelligents.

**Le workflow n'est pas rapide. Mais il est cohérent.**

Chaque fonctionnalité suit le même processus. Chaque tâche reçoit le même examen. La qualité reste élevée même quand la vélocité augmente.

---

## Les Leçons Durement Acquises

Après sept semaines, des douzaines de tâches, et d'innombrables erreurs, voici ce que j'ai appris sur le développement assisté par IA à l'échelle d'une large codebase.

### Ce En Quoi L'IA Excel Vraiment

**Explorer les grandes codebases** - L'IA peut lire des milliers de lignes plus vite que n'importe quel humain. Pointez-la vers un module complexe et demandez "qu'est-ce que ça fait ?" Véritablement utile.

**Reconnaissance de patterns** - Quand correctement guidée, l'IA repère des patterns que vous manqueriez. Elle voit la même approche de gestion d'erreur répétée dans 20 fichiers pendant que vous êtes encore sur le fichier 3.

**Analyse multi-modèle** - Différents modèles attrapent différents problèmes. Comme la revue de code avec plusieurs devs, chacun apporte une perspective différente.

### Ce En Quoi L'IA Échoue Constamment

**Prendre des décisions architecturales** - L'IA va concevoir des systèmes élaborés qui marchent en isolation mais ne s'intègrent pas à votre codebase. Chaque fois que vous laissez l'IA décider de l'architecture, vous créez du travail de refactoring pour plus tard.

**Maintenir la cohérence** - Sur plusieurs fichiers, l'IA dérive. Le fichier 1 utilise un pattern. Le fichier 5 utilise un pattern différent. Le fichier 10 invente un troisième pattern. Vous devez attraper ça.

**Gérer son propre contexte** - Après 60% d'utilisation du contexte, la qualité s'effondre. L'IA ne le sait pas. Elle continuera à générer des déchets en toute confiance.

**Refactoriser sans casser les choses** - Demandez à l'IA d'"améliorer" le code et regardez-la créer de la dette technique à une vitesse impressionnante. Elle ajoutera des abstractions dont vous n'avez pas besoin et supprimera des patterns sur lesquels vous comptez.

### Les Quatre Règles Qui Comptent Vraiment

**1. La Gestion du Contexte Est Tout**

La qualité de l'IA a une limite dure à ~60% d'utilisation du contexte. Respectez cette limite ou payez le prix en hallucinations.

Solutions :

- Effacer le contexte fréquemment
- Démarrer de nouvelles conversations souvent
- Supprimer les serveurs MCP trop gourmands
- Utiliser des fichiers work-in-progress pour suivre l'état entre les sessions

**2. La Compréhension Humaine N'Est Pas Négociable**

Vous ne pouvez pas externaliser la compréhension à l'IA. Point.

L'IA amplifie ce que vous savez. Elle ne remplace pas le fait de savoir des choses. Chaque fois que j'ai essayé de sauter la compréhension du code legacy, je l'ai payé plus tard en temps de débogage.

**3. La Structure Bat l'Intelligence**

Le prompting ad-hoc produit des résultats incohérents. Les workflows standardisés produisent des résultats fiables.

Construisez des templates. Créez des checklists. Documentez votre processus. Rendez-le ennuyeux et répétable.

**4. Vous Êtes l'Architecte**

L'IA est un dev junior talentueux qui écrit du code propre mais prend des décisions de design questionnable.

Vous concevez l'architecture. L'IA implémente les détails. Inversez ça et vous détesterez votre codebase dans trois mois.

## Parlons du Temps

Tout le monde veut savoir : "Est-ce que l'IA fait vraiment gagner du temps ?"

La réponse n'est pas simple. Voici la vraie répartition :

| Phase                              | Investissement Temps                              |
| ---------------------------------- | ------------------------------------------------- |
| **Tentatives initiales "Full IA"** | Jours d'efforts gaspillés                         |
| **Raffinement du workflow**        | ~7 semaines d'expérimentation                     |
| **Workflow actuel par feature**    | 25 min planification + 2-3 heures implémentation  |
| **Corrections manuelles**          | Significativement réduit mais toujours nécessaire |
| **Développement d'outils (CLI)**   | Coût initial, gains de productivité continus      |

**La vérité brutale ?** La courbe d'apprentissage était réelle. Durant la première semaine, l'IA était plus lente que le travail manuel à cause du temps passé à corriger ses erreurs. À la deuxième semaine, on atteignait la parité avec le travail manuel. Mais à la quatrième semaine, avec un workflow rodé, l'IA permettait d'aller 4x plus vite que le travail manuel.

**Est-ce que ça en vaut la peine ?**

Pour ce type de migration complexe, la réponse est clairement oui. L'IA apporte des bénéfices concrets : elle lit et explore des milliers de lignes de code pendant que je prends un café, ce qui est véritablement précieux. Écrire le 15ème endpoint CRUD moi-même serait écrasant pour l'âme, tandis que l'IA le fait en secondes. L'analyse multi-modèle, qui équivaudrait à employer trois devs juniors, tourne simplement sur mon laptop. Enfin, l'IA génère des listes de tâches détaillées et standardisées qui me prendraient des heures à produire manuellement.

Mais voici ce que la foule "l'IA va 10x votre productivité" ne vous dira pas : vous devez toujours reviewer chaque ligne, chaque fichier, chaque décision architecturale. Vous devez toujours concevoir l'architecture vous-même - l'IA ne peut que l'implémenter. Et vous devez toujours déboguer les problèmes bizarres, sachant que les bugs générés par IA sont souvent plus subtils et insidieux que ceux que vous écririez vous-même.

Le gain de productivité est réel. Mais c'est plutôt 2.5-4x pour les développeurs prudents, pas 10x.

## Si Vous Êtes Sur Le Point De Faire Ça : Lisez Ceci D'Abord

Vous planifiez une migration similaire ? Apprenez de mes erreurs.

### Les Sept Règles Pour Une Migration Assistée Par IA

**1. Ne commencez pas avec de l'IA autonome**

Je sais que c'est tentant. "Laissez juste l'IA gérer !"

Ne le faites pas. Vous perdrez des jours à corriger des hallucinations qui semblaient correctes au premier coup d'œil.

Commencez avec une supervision serrée. Relâchez graduellement en apprenant ce que l'IA réussit et où elle échoue.

**2. Investissez dans l'outillage dès le départ**

La soirée que j'ai passé à construire la CLI s'est payé en une semaine.

L'outillage custom semble être du surcoût jusqu'à ce que vous lanciez votre dixième migration de fonctionnalité et que tout marche simplement.

**3. Modèles multiples > Modèle unique**

Différents modèles IA attrapent différentes erreurs. Lancez-les en parallèle. Validez croisée les découvertes.

Oui, ça coûte plus cher. Ça attrape aussi les hallucinations avant qu'elles atteignent la production.

**4. L'auto-accept est un piège**

Regarder l'IA commiter des changements automatiquement pendant que vous prenez un café peut sembler productif, mais c'est une illusion dangereuse. En réalité, c'est jouer avec votre codebase et prendre des risques inutiles. Il faut reviewer chaque changement, sans exception.

**5. Vous concevez l'architecture**

30 minutes de travail d'architecture manuelle économise 3 heures de refactoring d'abstractions générées par IA qui ne s'intègrent pas à votre système.

**6. Effacez le contexte comme si la qualité de votre code en dépendait**

Parce que c'est exactement le cas. Après 60% d'utilisation de la fenêtre de contexte, la qualité de l'IA s'effondre brutalement. Il faut recommencer fréquemment à neuf pour maintenir des résultats fiables.

**7. Standardisez tout**

Créez des templates de prompts. Construisez des checklists. Documentez le workflow.

La cohérence bat l'intelligence quand vous migrez des douzaines de fonctionnalités.

### La Crise de la Code Review

Avertissement : vous générerez du code plus vite que votre équipe ne peut le reviewer.

Ça crée un nouveau goulot d'étranglement. Solutions qui ont marché pour nous :

**Stratégies de branches imbriquées** - N'attendez pas l'approbation PR pour démarrer la prochaine fonctionnalité. Branchez depuis votre branche.

**PRs plus petites, atomiques** - 50 fichiers c'est trop. 5-8 c'est gérable.

**Couverture de tests lourde** - Les tests automatisés réduisent le fardeau de revue. Si les tests passent, le reviewer se concentre sur l'architecture.

**Sessions de revue programmées** - Bloquez des fenêtres d'une heure pour du travail de revue profonde. Les revues rapides de 15 minutes manquent les problèmes subtils.

### Quand Sauter Toute Cette Approche

Ce workflow a du sens pour les migrations complexes, mais il serait excessif pour des contextes plus simples. Pour les petits projets, utilisez simplement Cursor et avancez rapidement sans trop de structure. Pour les prototypes où l'architecture peut évoluer librement, shippez et itérez sans contraintes. Si vous apprenez une nouvelle technologie, prenez le temps de comprendre par vous-même d'abord avant d'introduire l'IA. Enfin, pour les applications CRUD simples avec des patterns standards, l'IA brille naturellement sans avoir besoin de toute cette structure.

Gardez le workflow structuré pour les problèmes qui en ont vraiment besoin.

## La Conclusion

Voici ce que personne vendant des outils IA ne veut admettre :

**L'IA ne remplace pas les développeurs. Elle change sur quoi on passe notre temps.**

Avant l'IA : Je passais 50% de mon temps à lire du code legacy, 10% à réfléchir à l'architecture et 40% à écrire du code.

Avec l'IA : Je passe 10% à écrire du code, 60% à reviewer la sortie IA et prendre des décisions architecturales et 30% à lire du code legacy.

Le total d'heures ? 2-4x plus rapide qu'avant.

La différence ? Je n'écris plus de boilerplate. Je n'implémente plus le quinzième endpoint CRUD à la main. Je ne tape plus les cas de tests répétitifs.

À la place, je consacre mon temps à concevoir des systèmes, review les implémentations, attraper des bugs subtils et prendre des décisions stratégiques. C'est en fait une amélioration significative par rapport à avant.

Écrire du boilerplate n'a jamais été la partie intéressante du développement. Concevoir des systèmes élégants et résoudre des problèmes complexes, en revanche, c'est exactement pourquoi je suis entré dans ce domaine.

L'IA gère les parties ennuyeuses. Je gère les parties intéressantes.

Après sept semaines et des douzaines de tâches migrées, cette division du travail semble finalement juste.

## En résumé

**Le développement assisté par IA à l'échelle nécessite plus de structure, pas moins.**

Vous ne pouvez pas juste pointer l'IA vers un problème et espérer pour le mieux. Vous avez besoin de :

- Supervision humaine serrée
- Gestion agressive du contexte
- Workflows standardisés
- Outillage custom pour votre cas d'usage spécifique

Construisez la structure. Apprenez les outils. Comprenez leurs limites. Reviewez tout.

Faites ça, et vous verrez de vrais gains de productivité 2-4x sur le travail complexe.

Sautez ces étapes, et vous passerez plus de temps à déboguer les hallucinations que vous n'en auriez passé à écrire le code manuellement.

**Le futur du développement n'est pas l'IA autonome**, mais plutôt des développeurs qui maîtrisent l'art de diriger l'IA efficacement dans des workflows bien structurés. C'est là que résident les vrais gains de productivité. Et honnêtement, ce futur est déjà là - il suffit d'être prêt à faire le travail nécessaire pour y arriver.

---

_Sept semaines dedans, des douzaines de tâches migrées, et le workflow semble finalement productif. Pas magique. Pas autonome. Juste... productif. Parfois c'est suffisant._
